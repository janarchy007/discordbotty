"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Guild_instances, _Guild_parseVoiceStates, _Guild_fetchChannels;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Guild = exports.fetchGuild = exports.setData = void 0;
const undici_1 = require("undici");
const util_1 = require("./util");
let token;
function setData(botToken) {
    return __awaiter(this, void 0, void 0, function* () {
        token = botToken;
    });
}
exports.setData = setData;
function fetchGuild(guildID) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, undici_1.request)(`https://discord.com/api/v10/guilds/${guildID}`, {
            method: "GET",
            headers: {
                Authorization: `Bot ${token}`
            }
        });
        const data = yield (0, util_1.getJSONResponse)(response.body);
        return new Guild(data);
    });
}
exports.fetchGuild = fetchGuild;
function fetchGuildVoiceStates(guildID, token) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, undici_1.request)(`https://discord.com/api/v10/guilds/${guildID}/voice-states`, {
            method: "GET",
            headers: {
                Authorization: `Bot ${token}`,
            },
        });
        return yield (0, util_1.getJSONResponse)(response.body);
    });
}
function fetchGuildChannels(guildID, token) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, undici_1.request)(`https://discord.com/api/v10/guilds/${guildID}/channels`, {
            method: "GET",
            headers: {
                Authorization: `Bot ${token}`
            }
        });
        return yield (0, util_1.getJSONResponse)(response.body);
    });
}
class Guild {
    constructor(guildData) {
        _Guild_instances.add(this);
        this.id = guildData.id;
        this.name = guildData.name;
        this.icon = guildData.icon;
        this.description = guildData.description;
        this.splash = guildData.splash;
        this.discoverySplash = guildData.discovery_splash;
        this.features = guildData.features;
        this.emojis = guildData.emojis;
        this.banner = guildData.banner;
        this.ownerId = guildData.owner_id;
        this.applicationId = guildData.application_id;
        this.region = guildData.region;
        this.channels = new Map();
        this.afkChannelId = guildData.afk_channel_id;
        this.afkTimeout = guildData.afk_timeout;
        this.aflChannelId = guildData.afk_channel_id;
        this.afkTimeout = guildData.afk_timeout;
        this.systemChannelId = guildData.system_channel_id;
        this.widgetEnabled = guildData.widget_enabled;
        this.widgetChannelId = guildData.widget_channel_id;
        this.verificatioLevel = guildData.verification_level;
        this.roles = new Map();
        this.defaultMessageNotifications = guildData.default_message_notifications;
        this.explicitContentFilter = guildData.explicit_content_filter;
        this.mfaLevel = guildData.mfa_level;
        this.maxPresences = guildData.max_presences;
        this.maxMembers = guildData.max_members;
        this.maxVideoChannelUsers = guildData.max_video_channel_users;
        this.vanityUrlCode = guildData.vanity_url_code;
        this.premiumTier = guildData.premium_tier;
        this.premiumSubscriptionCount = guildData.premium_subscription_count;
        this.systemChannelFlags = guildData.system_channel_flags;
        this.preferredLocale = guildData.preferred_locale;
        this.publicUpdatesChannelId = guildData.public_updates_channel_id;
        this.rulesChannelId = guildData.rules_channel_id;
        this.voiceStates = __classPrivateFieldGet(this, _Guild_instances, "m", _Guild_parseVoiceStates).call(this, guildData.voice_states);
        __classPrivateFieldGet(this, _Guild_instances, "m", _Guild_fetchChannels).call(this);
    }
    fetchChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            const channels = yield fetchGuildChannels(this.id, token);
            const channelsMap = new Map();
            for (const channel of channels) {
                channelsMap.set(channel.id, channel);
            }
            return channelsMap;
        });
    }
    updateVoiceStates(voiceState) {
        return __awaiter(this, void 0, void 0, function* () {
            this.voiceStates.set(voiceState.user_id, voiceState);
        });
    }
}
exports.Guild = Guild;
_Guild_instances = new WeakSet(), _Guild_parseVoiceStates = function _Guild_parseVoiceStates(voiceStates) {
    const voiceStatesMap = new Map();
    if (voiceStates) {
        for (const voiceState of voiceStates) {
            voiceStatesMap.set(voiceState.user_id, voiceState);
        }
    }
    return voiceStatesMap;
}, _Guild_fetchChannels = function _Guild_fetchChannels() {
    return __awaiter(this, void 0, void 0, function* () {
        yield fetchGuildChannels(this.id, token).then((channels) => {
            for (const channel of channels) {
                this.channels.set(channel.id, channel);
            }
        });
    });
};
