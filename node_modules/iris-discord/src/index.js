"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.voiceAdapterCreator = void 0;
const websocket_1 = require("websocket");
const events_1 = __importDefault(require("events"));
const undici_1 = require("undici");
const util_1 = require("./util");
const guild_1 = require("./guild");
const message_1 = require("./message");
const voice_1 = require("@discordjs/voice");
let botToken;
let baseApiUrl = 'https://discord.com/api/v10/';
const methodMap = new Map();
function voiceAdapterCreator(userID, guildID) {
    const key = `${userID}.${guildID}`;
    return methods => {
        methodMap.set(key, methods);
        return {
            sendPayload: payload => {
                return !!payload;
            },
            destroy: () => {
                methodMap.delete(key);
            }
        };
    };
}
exports.voiceAdapterCreator = voiceAdapterCreator;
class Client {
    constructor(data) {
        this.events = new events_1.default.EventEmitter();
        this.cache = new util_1.cache();
        this.VoiceConnections = new Map();
        this.ws = new websocket_1.client();
        this.intentsArray = data.intents;
        this.intents = 20;
        this.heartBeater = new util_1.heartBeater();
        this.voiceAdpters = new Map();
        this.heartBeater.onHeartBeat((count) => {
            this.events.emit('heartbeat', count);
        });
        for (const intent of this.intentsArray) {
            this.intents += intent;
        }
    }
    on(event, callback) {
        this.events.on(event, callback);
    }
    once(event, callback) {
        this.events.once(event, callback);
    }
    joinVoiceChannel(channelId, guildId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, voice_1.joinVoiceChannel)({
                channelId: channelId,
                guildId: guildId,
                adapterCreator: this.getGuildVoiceAdapterCreator(guildId)
            });
        });
    }
    getGuildVoiceAdapterCreator(guildId) {
        return (methods) => {
            this.voiceAdpters.set(guildId, methods);
            return {
                sendPayload: (payload) => {
                    this.connection.sendUTF(JSON.stringify(payload));
                    return true;
                },
                destroy: () => {
                    this.voiceAdpters.delete(guildId);
                }
            };
        };
    }
    login(token) {
        return __awaiter(this, void 0, void 0, function* () {
            botToken = token;
            (0, guild_1.setData)(botToken);
            (0, message_1.setData)(botToken);
            const gateWayData = yield (0, undici_1.request)('https://discord.com/api/v10/gateway/bot', {
                method: 'GET',
                headers: {
                    Authorization: `Bot ${token}`
                }
            });
            const gateWayUrl = yield (0, util_1.getJSONResponse)(gateWayData.body).then((data) => data.url).then((url) => {
                return url + '?v=10&encoding=json';
            });
            this.ws.on('connectFailed', (error) => {
                throw new Error(error);
            });
            this.ws.on('connect', (connection) => {
                this.connection = connection;
                connection.on('message', (message) => __awaiter(this, void 0, void 0, function* () {
                    if (message.type === 'utf8') {
                        const data = JSON.parse(message.utf8Data);
                        if (data.op === 10) {
                            this.heartBeater.start(data.d.heartbeat_interval, connection);
                        }
                        else if (data.op === 0) {
                            if (data.t === 'READY') {
                                this.user = data.d.user;
                                this.resumeGatewayUrl = data.d.resume_gateway_url;
                                this.sessionId = data.d.session_id;
                                this.sessionType = data.d.session_type;
                                this.events.emit('ready');
                            }
                            else if (data.t === 'GUILD_CREATE') {
                                this.cache.addGuild(new guild_1.Guild(data.d));
                                this.events.emit('guildCreate', new guild_1.Guild(data.d));
                            }
                            else if (data.t === 'MESSAGE_CREATE') {
                                this.events.emit('messageCreate', new message_1.Message(data.d));
                            }
                            else if (data.t === 'VOICE_STATE_UPDATE') {
                                if (data.d.channel_id) {
                                    this.cache.addVoiceState(data.d);
                                    this.cache.guilds.get(data.d.guild_id).voiceStates.set(data.d.channel_id, data.d);
                                }
                                else {
                                    this.cache.guilds.get(data.d.guild_id).voiceStates.set(data.d.channel_id, data.d);
                                    this.cache.removeVoiceState(data.d);
                                }
                                const userID = this.user.id;
                                const guildID = data.d.guild_id;
                                const methods = this.voiceAdpters.get(guildID);
                                if (methods) {
                                    methods.onVoiceStateUpdate(data.d);
                                }
                                this.events.emit('voiceStateUpdate', data.d);
                            }
                            else if (data.t === 'VOICE_SERVER_UPDATE') {
                                const userID = this.user.id;
                                const guildID = data.d.guild_id;
                                const methods = this.voiceAdpters.get(guildID);
                                if (methods) {
                                    methods.onVoiceServerUpdate(data.d);
                                }
                            }
                        }
                    }
                }));
                connection.sendUTF(JSON.stringify({
                    op: 2,
                    d: {
                        token: token,
                        intents: this.intents,
                        properties: {
                            $os: 'linux',
                            $browser: 'iris',
                            $device: 'iris'
                        }
                    }
                }));
            });
            this.ws.connect(gateWayUrl);
        });
    }
}
exports.Client = Client;
